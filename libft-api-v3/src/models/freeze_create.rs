/*
 * Intra v3 - Freeze
 *
 * API for Freeze management for staff and students
 *
 * The version of the OpenAPI document: 2.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// FreezeCreate : Create Model used for single and bulk freeze create
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct FreezeCreate {
    #[serde(rename = "user_id")]
    pub user_id: Box<models::UserId>,
    #[serde(rename = "begin_date")]
    pub begin_date: String,
    #[serde(rename = "expected_end_date")]
    pub expected_end_date: String,
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<Reason>,
    #[serde(rename = "category", skip_serializing_if = "Option::is_none")]
    pub category: Option<Category>,
    #[serde(rename = "is_free_freeze", skip_serializing_if = "Option::is_none")]
    pub is_free_freeze: Option<bool>,
    #[serde(rename = "status", skip_serializing_if = "Option::is_none")]
    pub status: Option<Status>,
    #[serde(
        rename = "student_description",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub student_description: Option<Option<String>>,
    #[serde(
        rename = "staff_description",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub staff_description: Option<Option<String>>,
}

impl FreezeCreate {
    /// Create Model used for single and bulk freeze create
    pub fn new(
        user_id: models::UserId,
        begin_date: String,
        expected_end_date: String,
    ) -> FreezeCreate {
        FreezeCreate {
            user_id: Box::new(user_id),
            begin_date,
            expected_end_date,
            reason: None,
            category: None,
            is_free_freeze: None,
            status: None,
            student_description: None,
            staff_description: None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Reason {
    #[serde(rename = "medical")]
    Medical,
    #[serde(rename = "personal")]
    Personal,
    #[serde(rename = "professional")]
    Professional,
    #[serde(rename = "other")]
    Other,
}

impl Default for Reason {
    fn default() -> Reason {
        Self::Medical
    }
}
///
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Category {
    #[serde(rename = "regular")]
    Regular,
    #[serde(rename = "bonus")]
    Bonus,
    #[serde(rename = "compensation")]
    Compensation,
}

impl Default for Category {
    fn default() -> Category {
        Self::Regular
    }
}
///
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Status {
    #[serde(rename = "approved")]
    Approved,
    #[serde(rename = "rejected")]
    Rejected,
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "interrupted")]
    Interrupted,
    #[serde(rename = "ongoing")]
    Ongoing,
    #[serde(rename = "finished")]
    Finished,
    #[serde(rename = "reverted")]
    Reverted,
}

impl Default for Status {
    fn default() -> Status {
        Self::Approved
    }
}
